#!/usr/bin/perl -w
use Cwd;
system('stty iutf8');

###############
##   Title   ##
###############################################################################

my $header = <<'EOHEADER';
------------------------------------------------------------------------------
		     AGroS - Automatic Gromacs Simulations		      
------------------------------------------------------------------------------
									      
 AGroS is a script package to allow easy setup and run of MD simulation using
 GROMACS. The input is a pdb file or pdb identifier. Single or multiple chain
 proteins are supported. Protein / DNA complexes are still in development. In 
 the future we hope to support different pHs and special ligands.
 
 To analyze the results  we will soon release  GroSA and SAGros, two packages 
 to do stanadard analysis and then subsequently statistical analysis.									      
									      
									      
		     Authors: (C) Marc Offman				      
			       Date: 05.03.2012 			      
			       Version: 0.6b				      
									      
									      
			  Thank you for using AGroS!			      
	    Any questions should be adressed to offman@rostlab.org	      
									      
------------------------------------------------------------------------------

EOHEADER
print $header;
###############
##   STEPS   ##
###############################################################################

# Steps:

# 1- Runs RepairPDB and findBreaks, additional scripts to adapt PDB files to MD reality.
# 2- Runs STRWater, an additional script that saves information for Structural Water Molecules in PDB file.
# 3- Runs SCWRL, a program employed to correctly assign side chain information to PDB structures.
# 4- Runs minimization in vacuum.
# 5- Creates water box, includes solvent (water with 0.1 [NaCl]) and neutralizes protein intrinsic charge.
# 6- Creates restrain files for each chain individually.
# 7- Runs solvent minimization with fixed Protein (backbone + sidechains).
# 8- Runs minimization with fixed Backbone.
# 9- Runs short production NVT MD.
# 10- Runs short production NPT MD.
# 11- Runs Production MD.

###############################################################################

##############
##  DEFVAR  ##
###############################################################################
# 1)
# Set value for pme (particle mesh Ewald):
$pme = 4;	# Default value is 4

# 2)
# Set value for B-Factor Cutoff value when defining Structural Water Molecules:
$strwcut = 15;	# Default cutoff is 15 angstrons

# 3)
# Set the desired Verbose option (uncomment the line to choose the option):
#$VERBOSE = "";
$VERBOSE = "-v";	# Default option is ON (-v)

# 4)
# Define type of water box:
$boxtype="dodecahedron";	# Default option is the dodecahedric box
# Other box types include "" .

# 5)
# Turn ON/OFF Scwrl, for side chain treatment (uncomment the line to choose the option):
# OFF --> $scwrl = 0
# ON  --> $scwrl = 1
$scwrl = 1;	# Default option is ON (1)

$swjp = 0;
$swver = 0;

# 6)
# Define the size of steps for the simulation:
$stepsize = 0.005;	# Default stepsize of 5fs (0.005 ps)
$minsteps = 5000;
$emtol = 10.0;

# 7)
# Define the length of the NVT and NPT simulations (in pico seconds):
$lengthNVPT = 50;	# Default lenght of 50ns (10000 ps)

# 8)
# Define the length of the MD simulation (in pico seconds):
#$lengthMD = 2000;	# Default lenght of 10ns (10000 ps)
$lengthMD = 10000;	# Default lenght of 10ns (10000 ps)

$dna = 0;
$threads = 1;

##############
##   INPUT  ##
###############################################################################
# Get Input
###############################################################################
$path = $ENV{'HOME'}."/projects/md";
$pathGromacs = "";
$pathScwrl = "";
$pathScripts = "";

# Get parameters (PDB file and number of nodes):
if(not defined $ARGV[0]){
	&printHelp;
}
for($i = 0; $i < @ARGV; $i++){
	$key = $ARGV[$i];
	$key=~s/\s+//g;
	$key = lc($key);
	if($key eq "-h"){
		&printHelp;
	}
	elsif($key eq "-dir"){
		if(defined $ARGV[$i+1] && -e "$ARGV[$i+1]"){
			$path = $ARGV[$i+1];
		}
		else{
			print STDERR "Directory $ARGV[$i+1] does not exist.\n";
			exit(1);
		}
	}
	elsif($key eq "-threads"){
		if(defined $ARGV[$i+1] && $ARGV[$i+1] =~m/\d+/){
			$threads = $ARGV[$i+1];
			if($threads != 1 && (($threads % 2) != 0 || $threads == 0)){
				print STDERR "threads: value must either be 1 or an even integer!\n";
				exit(1);
			}
		}
		else{
			print STDERR "threads: value needs to be integer!\n";
			exit(1);
		}
	
	}
	elsif($key eq "-noscwrl"){
		$scwrl = 0;
	}
	elsif($key eq "-v"){
		$swver = 1;
	}
	elsif($key eq "-minsteps"){
		if(defined $ARGV[$i+1] && $ARGV[$i+1] =~m/^\d+$/){
			$minsteps = $ARGV[$i+1];
			if($minsteps < 3000){
				print STDERR "Warning: value is set to $minsteps, but should not be lower than 3000!\n";
			}
		}
		else{
			print STDERR "minSteps: value needs to be integer!\n";
			exit(1);
		}
	}
	elsif($key eq "-lengthnvpt"){
		if(defined $ARGV[$i+1] && $ARGV[$i+1] =~m/^\d+$/){
			$lengthNVPT = $ARGV[$i+1];
			if($lengthNVPT < 50){
				print STDERR "Warning: value is set to $lengthNVPT ps, but should not be lower than 50!\n";
			}
		}
		else{
			print STDERR "lengthNVPT: value needs to be integer!\n";
			exit(1);
		}
	}
	elsif($key eq "-lengthmd"){
		if(defined $ARGV[$i+1] && $ARGV[$i+1] =~m/^\d+$/){
			$lengthMD = $ARGV[$i+1];
		}
		else{
			print STDERR "lengthMD: value needs to be integer!\n";
			exit(1);
		}
	}
	elsif($key eq "-cutoffstrw"){
		if(defined $ARGV[$i+1] && $ARGV[$i+1] =~m/^\d+$/){
			$strwcut = $ARGV[$i+1];
		}
		else{
			print STDERR "cutoffstrw: value needs to be integer!\n";
			exit(1);
		}
	}
	elsif($key eq "--gromacspath"){
		if(defined $ARGV[$i+1] && -e "$ARGV[$i+1]"){
			$pathGromacs = $ARGV[$i+1];
		}
		else{
			print STDERR "$ARGV[$i+1] is not a valid path!\n";
			exit(1);
		}
	}
	elsif($key eq "--scwrlpath"){
		if(defined $ARGV[$i+1] && -e "$ARGV[$i+1]"){
			$pathScwrl = $ARGV[$i+1];
		}
		else{
			print STDERR "$ARGV[$i+1] is not a valid path!\n";
			exit(1);
		}
	}
	elsif($key eq "--scriptpath"){
		if(defined $ARGV[$i+1] && -e "$ARGV[$i+1]"){
			$pathScripts = $ARGV[$i+1];
		}
		else{
			print STDERR "$ARGV[$i+1] is not a valid path!\n";
			exit(1);
		}
	}
	elsif($key =~m /([a-z,0-9]\:)+/){
		$key = uc($key);
		$key =~ s/\://g;
		$chains{$key} = 1;
	}
	elsif($key eq "--jp"){
		$swjp = 1;
	}	
}

if (defined $ENV{'LRZ_SYSTEM'}){
	$scwrl = 0;
	print "WE ARE ON THE LRZ, RIGHT?\n";
}
#Figure which mpi to use
$call = "mdrun";
$check = `which mpirun 2>& 1`;
chomp($check);
if(-e "$check"){
	$call = "mpirun -n $threads mdrun_mpi";
}
$check = `which mpiexec 2>& 1`;
chomp($check);
if(-e "$check"){
	$call = "mpiexec -n $threads mdrun_mpi";
}
$check = `which srun_ps 2>& 1`;
chomp($check);
if(-e "$check"){
	$call = "srun_ps mdrun_mpi";
}
print "MDRUN will be called like this: \"$call\"\n\n";
#exit;


#check if pdb file exists; if pdb code is defined try to fetch pdb using fetchpdb
if(! -e "$ARGV[0]"){
	$tmpPDB = lc($ARGV[0]);
	if($ARGV[0] =~ m/^[0-9][0-9,a-z]{3}$/){
		$reval = `fetchpdb $tmpPDB`;
		chomp($reval);
		if(! -e "$tmpPDB.pdb"){
			print STDERR "Problem with loading $ARGV[0] from the RCSB\n";
			exit(1);
		}
		else{
			$dir = getcwd;
			$input = "$dir/$tmpPDB.pdb";
		}
	}
	else{
		print STDERR "Cannot find the input file or pdb code invalid: $ARGV[0]\n";
		exit(1);
	}
}
else{
	$input = $ARGV[0];
}


###############################################################################

###############################################################################
# Automatically assign the number of steps (do not edit the following lines):
$rlNVPT = $lengthNVPT/$stepsize;
$rlMD   = $lengthMD/$stepsize;
###############################################################################

##############
##  DEFENV  ##
###############################################################################
if($pathGromacs ne ""){
	$ENV{PATH} .= ":$pathGromacs";
}
if($pathScripts ne ""){
	$ENV{PATH} .= ":$pathScripts";
}
$check = `which pdb2gmx`;
chomp($check);
if($check eq ""){
	print "Could not find the gromacs binaries; please define in PATH or commandline!\n";
	exit(1);
}

if($pathScwrl ne ""){
	$ENV{PATH} .= ":$pathScwrl";
}
if($scwrl == 1){
	$check = `which scwrl`;
	chomp($check);
	if($check eq ""){
		print "Could not find the scwrl binary; please define in PATH or commandline!\n";
		exit(1);
	}
}

###############################################################################

#PRINT SETTINGS###################################################################
print "Your settings are:\n";
print "------------------------------------------------------------------------------\n";
print "$input\n";
if(defined %chains){
	$chainSTR = "";
	foreach $key(sort keys %chains){
		$chainSTR .= "$key: ";
	}
	print "Chains: 			$chainSTR\n";
}
print "Number of processors:		$threads\n";
print "SCWRL:				$scwrl\n";
print "Structural water cutoff:	$strwcut\n";
print "Steps minimization:		$minsteps\n";
print "Length NVT & NPT:		$lengthNVPT ps\n";
print "Length production:		$lengthMD ps\n";
print "------------------------------------------------------------------------------\n\n";
##################################################################################
#exit;

##############
##  WARMUP  ##
###############################################################################
# Get the name of the PDB file:
@tmp = split/\//,$input;
$root = pop(@tmp);

$root =~ s/\.pdb//;

if(! -e "$path/mdrun_$root"){
	`mkdir -p $path/mdrun_$root`;
}
$newDir = "$path/mdrun_$root";
###############################################################################



###############
##   STEP1   ##
###############################################################################

# 1- Runs RepairPDB and findBreaks, additional scripts to adapt PDB files to MD reality.

###############################################################################
($tmp,$min,$hour,$mday,$mon,$tmp,$tmp,$tmp,$tmp) = localtime(time);
my @abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
$log_out = "$path/mdrun_$root/$root.stdout";
$log_err = "$path/mdrun_$root/$root.stderr";

if(defined %chains){
	$chainSTR = "";
	foreach $key(sort keys %chains){
		$chainSTR .= "$key: ";
	}
	`repairPDB $input $chainSTR > $path/mdrun_$root/$root.ref`;
}
else{
	`cp $input $path/mdrun_$root/$root.ref`;
}
if(! -e "$log_out"){
	`touch $log_out`;
}
`echo \"$abbr[$mon] $mday  $hour:$min\" >> $log_out`;
if(! -e "$log_err"){
	`touch $log_err`;
}
`echo \"$abbr[$mon] $mday  $hour:$min\" >> $log_err`;


#remove clashing water
`clshwtr.pl $path/mdrun_$root/$root.ref 2.6 > $path/mdrun_$root/$root.nclw`;

# RUN additional script REPAIRPDB:
`repairPDB $path/mdrun_$root/$root.ref -nohoh > $path/mdrun_$root/$root.pdb`;
`clshwtr.pl $path/mdrun_$root/$root.ref 2.6 >> $path/mdrun_$root/$root.pdb`;

chdir($newDir) or die "$!";

`repairPDB $path/mdrun_$root/$root.pdb -jprot > $path/mdrun_$root/$root\_br.pdb`;
$nrChains = `sepPDB $path/mdrun_$root/$root\_br.pdb`;

# RUN additional script FINDBREAKS:
chomp($nrChains);
$breaks = 0;
for($r = 0; $r < $nrChains; $r++){
	if(`findBreaks.pl $path/mdrun_$root/$root\_br\_$r.pdb` ne ""){$breaks++;}
}
if($breaks > 0){
	
	print STDERR " Found breaks in the structure!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}

if(! -e "$path/mdrun_$root/$root.gro" || ! -e "$path/mdrun_$root/$root.top"){
	$newName = "$path/mdrun_$root/$root.pdb"."2";

	`repairPDB $path/mdrun_$root/$root.pdb -noh > $newName`;

	# - Prepare, set to 0 and remove PDB problems.
	open(PDB,"$newName");
	$oldres = 999999999;
	while(<PDB>){
		chomp($_);
		if(/^ATOM/){
			$res = substr($_,22,8);
			if($res < $oldres){
				$oldres = $res;
			}
		}

	}
	close PDB;
	$oldres = -($oldres);

	`repairPDB $newName -nodna -offset $oldres > $path/mdrun_$root/$root\_repair.pdb`;
	
	$nrChains = `sepPDB $path/mdrun_$root/$root\_repair.pdb`;
	chomp($nrChains);
	if($nrChains > 1){
		print STDERR " Multiple chains found fixing indices!\n";
		print STDERR "------------------------------------------------------------------------------\n";
		`repairPDB $path/mdrun_$root/$root\_repair.pdb -rres > $path/mdrun_$root/$root\_repair.pdb.tmp`;
		`mv $path/mdrun_$root/$root\_repair.pdb.tmp $path/mdrun_$root/$root\_repair.pdb`;
	}
	
	###############################################################################


	###############
	##   STEP2   ##
	###############################################################################

	# 2- Runs STRWater, an additional script that saves information for Structural Water Molecules in PDB file.

	###############################################################################
	# RUN additional script STRWater to get STR Waters:
	# The default cutoff value for B-Factor is 15.
	# Define a different cutoff using the var $strwcut at the 'DEFVAR' section.

	`repairPDB $path/mdrun_$root/$root.pdb -ssw $strwcut > $path/mdrun_$root/$root\_water.pdb`;
	`repairPDB $path/mdrun_$root/$root.pdb -dna > $path/mdrun_$root/$root\_dna.pdb`;
	if(! -z "$path/mdrun_$root/$root\_dna.pdb"){
		$dna = 1;
		$stepsize = 0.002;
		$rlNVPT = $lengthNVPT/$stepsize;
		$rlMD   = $lengthMD/$stepsize;
	}
	###############################################################################


	###############
	##   STEP3   ##
	###############################################################################

	# 3- Runs SCWRL, a program employed to correctly assign side chain information to PDB structures.

	###############################################################################

	# RUN additional program SCWRL to place side chains:

	if($scwrl == 1){
		# - Create sequence file for SCWRL.
		open(SEQ,"repairPDB $path/mdrun_$root/$root\_repair.pdb -seq |");
		while(<SEQ>){
			chomp($_);
			$seq = $_;
		}
		close SEQ;
		$seq = lc($seq);
		open(OUT,">$path/mdrun_$root/$root.seq");
		print OUT $seq;
		close OUT;
		$error = `scwrl -i $path/mdrun_$root/$root\_repair.pdb -o $path/mdrun_$root/$root\_sc.pdb -s $path/mdrun_$root/$root.seq` || die 'ERROR: Could not run SCWRL properly!';
	}
	else{
		`cp $path/mdrun_$root/$root\_repair.pdb $path/mdrun_$root/$root\_sc.pdb`;
	}	
	# - Get rid of hydrogen atoms.
	if(! -e "$path/mdrun_$root/$root\_sc.pdb"){
		
		print STDERR " No SCWRL structure!!!\n";
		print STDERR "------------------------------------------------------------------------------\n";
		print STDERR $error;
		exit;
	}	
	
	`repairPDB $path/mdrun_$root/$root\_sc.pdb -jprot > $path/mdrun_$root/$root\_nh.pdb`;
	#exit;
	if(defined $ARGV[2] && $ARGV[2] eq "simple"){
		`cp $path/mdrun_$root/$root.pdb $path/mdrun_$root/$root\_nh.pdb`;
	}
	
	# Append STR Water Molecules & DNA to SCWRL PDB File:
	`cat $path/mdrun_$root/$root\_dna.pdb >> $path/mdrun_$root/$root\_nh.pdb`;
	`cat $path/mdrun_$root/$root\_water.pdb >> $path/mdrun_$root/$root\_nh.pdb`;
#exit;
	#`echo TER >> $path/mdrun_$root/$root\_nh.pdb`;


	if(! -e "$path/mdrun_$root/$root\_nh.pdb"){
		
		print STDERR " Problems preparing the structure!!!\n";
		print STDERR "------------------------------------------------------------------------------\n";
		exit;
	}
	else{
		
		print STDERR " Structure prepared!\n";
		print STDERR "------------------------------------------------------------------------------\n";
	}
	###############################################################################
#exit;

	###############
	##   STEP4   ##
	###############################################################################

	# 4- Runs minimization in vacuum.

	###############################################################################

	# PDB2GMX:

	# - Option vsite hydrogens in pdb2gmx speeds up the MD protocol.
	# - Create top and charge file.
	if($dna == 0){
		`pdb2gmx -f $path/mdrun_$root/$root\_nh.pdb -o $path/mdrun_$root/$root.gro -p $path/mdrun_$root/$root.top -water tip3p -ff amber03 -vsite hydrogens -chainsep id_or_ter 2>$log_err 1>$log_out`;
	}
	else{
		`pdb2gmx -f $path/mdrun_$root/$root\_nh.pdb -o $path/mdrun_$root/$root.gro -p $path/mdrun_$root/$root.top -water tip3p -ff amber03 -chainsep id_or_ter  2>$log_err 1>$log_out`;
	}
}
if(! -e "$path/mdrun_$root/$root.gro" || ! -e "$path/mdrun_$root/$root.top"){
	
	print STDERR " Problems creating the simulation structure!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
else{
	
	print STDERR " Simulation structure created!\n";
	print STDERR "------------------------------------------------------------------------------\n";
}
#exit;
if($swjp == 1){
	print STDERR " Structure prepared for GROMACS!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
###############################################################################

###############
##   STEP5   ##
###############################################################################

# 5- Creates water box, includes solvent (water with 0.1 [NaCl]) and neutralizes protein intrinsic charge.

###############################################################################
#exit;
# Create Water Box:

	# - Define solvent box with 1 nm (10Ã…) distance to boarder and add solvent.
	# A dodecahedric box is defined by default. To set another box type, edit the content of $boxtype at the 'DEFVAR' section.
if(! -e "$path/mdrun_$root/$root\_water.pdb" || ! -e "$path/mdrun_$root/$root\_pbc.gro"){
	`editconf -f $path/mdrun_$root/$root.gro -o $path/mdrun_$root/$root\_pbc.gro -bt $boxtype -d 1.0 2>>$log_err 1>>$log_out`;
	`genbox -cp $path/mdrun_$root/$root\_pbc.gro -cs spc216.gro -p $path/mdrun_$root/$root.top -o $path/mdrun_$root/$root\_water.gro 2>>$log_err 1>>$log_out`;
}

if(! -e "$path/mdrun_$root/$root\_water.gro" || ! -e "$path/mdrun_$root/$root\_pbc.gro"){
	
	print STDERR " Problems adding water and box!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
else{
	
	print STDERR " Water and box added!\n";
	print STDERR "------------------------------------------------------------------------------\n";
}
# Fill it with water, neutralize the system and add ions to 0.1 NaCl concentration: 

#exit;
# Create MDP file:
	# - Add ions.
if(! -e "$path/mdrun_$root/$root\_solv.pdb"){
	open(OUT,"> $path/mdrun_$root/minim.mdp");
	print OUT "integrator		= steep\n";
	print OUT "emtol		= $emtol\n";
	print OUT "nsteps		= $minsteps\n";
	print OUT "nstenergy		= 1\n";
	print OUT "energygrps		= System\n";
	print OUT "coulombtype		= PME\n";
	print OUT "rcoulomb		= 0.9\n";
	print OUT "rvdw			= 0.9\n";
	print OUT "rlist		= 0.9\n";
	print OUT "fourierspacing 	= 0.12\n";
	print OUT "pme_order 		= $pme\n";
	print OUT "ewald_rtol 		= 1e-5\n";
	close OUT;

# Generate TPR file:
	`grompp $VERBOSE -f $path/mdrun_$root/minim.mdp -c $path/mdrun_$root/$root\_water.gro -p $path/mdrun_$root/$root.top -o $path/mdrun_$root/$root\_water.tpr 2>>$log_err 1>>$log_out`;
#exit;
	# - Add ions.
	$tmp = `genion -s $path/mdrun_$root/$root\_water.tpr -o $path/mdrun_$root/$root\_solv_tmp.pdb -conc 0.1 -neutral -pname NA+ -nname CL- 2>>$log_err <<EOF\n13\nEOF`;

	#get rid of duplicate water (very rare event)
	`repairPDB $path/mdrun_$root/$root\_solv_tmp.pdb -cleansol > $path/mdrun_$root/$root\_solv.pdb`;
	$removed_water = `grep \"REMARK RM\" $path/mdrun_$root/$root\_solv.pdb`;
	if($removed_water ne ""){
		$removed_water = (split/\s+/,$removed_water)[2];
	}
	else{
		$removed_water = 0;
	}

	# - Get the number of ions added.
	$na = (split/\s+/,$tmp)[4];
	$cl = (split/\s+/,$tmp)[8];
	$nr_replaced += $na+$cl;
	$allWater = 0;
	open(TOPOUT,">$path/mdrun_$root/$root\_solv.top");
	open(TOP,"$path/mdrun_$root/$root.top");
	while(<TOP>){
		chomp($_);
		if(/^SOL/){
			$nr_here = (split/\s+/,$_)[1];
			$allWater += $nr_here;
		}
		else{
			print TOPOUT "$_\n";
		}
	
	}
	close TOP;
	$nr_new = $allWater-($nr_replaced+$removed_water);
	
	print TOPOUT "SOL\t\t$nr_new\n";
	print TOPOUT "NA\t\t$na\n";
	print TOPOUT "CL\t\t$cl\n";
	close TOPOUT;
}
if(! -e "$path/mdrun_$root/$root\_solv_tmp.pdb"){
	
	print STDERR " Problems adding ions!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
else{
	
	print STDERR " Ions added!\n";
	print STDERR "------------------------------------------------------------------------------\n";
}
###############################################################################
#exit;

###############
##   STEP6   ##
###############################################################################

# 6- Creates restrain files for each chain individually.

###############################################################################

# Dealing with MULTIPLE CHAINS:


# Create POSRE files (one file per chain):
$cnt = 0;
$oldChain = "";
$rw = open(TMPIN,"$path/mdrun_$root/$root.ref");
if(not defined $rw){
        print "Could not open $path/mdrun_$root/$root.ref\n";
	exit;
}
while(<TMPIN>){
	chomp($_);
	#print "$_\n";
	if(/^ATOM/){
		$chainID = substr($_,21,1);
		if($chainID ne $oldChain){
			#print "|$oldChain| |$chainID|\n";
			if($chainID eq " "){
				$chain[$cnt] = "#";
			}
			else{
				$chain[$cnt] = $chainID;
			}
			$oldChain = $chainID;
			$cnt++;
		}
	}
}
close TMPIN;
`repairPDB $path/mdrun_$root/$root\_solv.pdb -jprot > $path/mdrun_$root/$root\_solv.pdb2`;
`repairPDB $path/mdrun_$root/$root\_solv.pdb -dna >> $path/mdrun_$root/$root\_solv.pdb2`;
$nrChains = `sepPDB $path/mdrun_$root/$root\_solv.pdb2`;
chomp($nrChains);

print STDERR " Number of chains $nrChains\n";
print STDERR "------------------------------------------------------------------------------\n";

$tmpin = `grep ATOM $path/mdrun_$root/$root\_solv.pdb | wc`;
$tmpin =~ s/^\s+//g;
$systemsize = (split/\s+/,$tmpin)[0];
print STDERR " Number of atoms $systemsize\n";
print STDERR "------------------------------------------------------------------------------\n";

#exit;

for($f = 0; $f < $nrChains; $f++){
	if(`grep \" DA \" $path/mdrun_$root/$root\_solv_$f.pdb` ne "" || `grep \" DT \" $path/mdrun_$root/$root\_solv_$f.pdb` ne ""  || `grep \" DC \" $path/mdrun_$root/$root\_solv_$f.pdb` ne ""  || `grep \" DG \" $path/mdrun_$root/$root\_solv_$f.pdb` ne ""){
		print " CHAIN $f: DNA\n";
		`genrestr -f $path/mdrun_$root/$root\_solv_$f.pdb -o $path/mdrun_$root/posre_DNA_chain_$chain[$f].itp 2>>$log_err 1>>$log_out <<EOF\n1\nEOF`;
	}
	else{
		print " CHAIN $f: Protein\n";
		`genrestr -f $path/mdrun_$root/$root\_solv_$f.pdb -o $path/mdrun_$root/posre_Protein_chain_$chain[$f].itp 2>>$log_err 1>>$log_out <<EOF\n1\nEOF`;
	}
	if($nrChains == 1){
		`mv $path/mdrun_$root/posre_Protein_chain_$chain[$f].itp $path/mdrun_$root/posre.itp`;
	}	
}


print STDERR " Constraint files created\n";
print STDERR "------------------------------------------------------------------------------\n";

###############################################################################
#exit;

###############
##   STEP7   ##
###############################################################################

# 7- Run solvent minimization with fixed Protein (backbone + sidechains).

###############################################################################

# RUN additional script REPAIRPDB:

print STDERR " Run min I: solvent & fixed protein(SD)\n";
if(! -e "$path/mdrun_$root/$root\_solv_min.pdb"){

# Create MDP file:
	open(OUT,"> $path/mdrun_$root/minim_solv.mdp");
	print OUT "define          	= -DPOSRES\n";
	print OUT "integrator		= steep\n";
	print OUT "emtol		= $emtol\n";
	print OUT "nsteps		= $minsteps\n";
	print OUT "nstenergy		= 1\n";
	print OUT "energygrps		= System\n";
	print OUT "coulombtype		= PME\n";
	print OUT "rcoulomb		= 0.9\n";
	print OUT "rvdw			= 0.9\n";
	print OUT "rlist		= 0.9\n";
	print OUT "fourierspacing 	= 0.12\n";
	print OUT "pme_order 		= $pme\n";
	print OUT "ewald_rtol 		= 1e-5\n";
	print OUT "pbc			= xyz\n";
	close OUT;

# Generate TPR file:
	`grompp $VERBOSE -f $path/mdrun_$root/minim_solv.mdp -c $path/mdrun_$root/$root\_solv.pdb -p $path/mdrun_$root/$root\_solv.top -o $path/mdrun_$root/$root\_solv_min.tpr 2>>$log_err 1>>$log_out`;
	# - Only minimize the solvent.

# RUN Minimization:
	print STDERR " Minimizing - step  ";
	$| = 1;
	$lengthStep = 1;
	open(RUN,"$call $VERBOSE -deffnm $path/mdrun_$root/$root\_solv_min -c $path/mdrun_$root/$root\_solv_min.pdb 2>& 1 | ");
	while(<RUN>){
		if($swver == 1){print $_;}
		if(/^Step=\s+([0-9]+), Dmax/){
			for($k = 0; $k < $lengthStep; $k++){
				print "\b";
			}
			print "$1";
			$lengthStep = length($1);
		}
	}
	close RUN;
	print STDERR "\n";
}
if(! -e "$path/mdrun_$root/$root\_solv_min.pdb"){
	
	print STDERR " Problems minimising solvent!!!        \n";
	print STDERR "------------------------------------------------------------------------------\n";

	exit;
}
else{
	
	print STDERR " Solvent minimized!\n";
	print STDERR "------------------------------------------------------------------------------\n";

}
###############################################################################
#exit;

###############
##   STEP8   ##
###############################################################################

# 8- Run minimization with fixed Backbone.

###############################################################################

# RUN additional script REPAIRPDB:

`repairPDB $path/mdrun_$root/$root\_solv_min.pdb -jprot > $path/mdrun_$root/$root\_solv_min.pdb2`;
$nrChains = `sepPDB $path/mdrun_$root/$root\_solv_min.pdb2`;

print STDERR " Run min II: solvent & fixed backbone(SD)\n";

# - Minimize all with backbone restrained.
if(! -e "$path/mdrun_$root/$root\_solv_min2.pdb"){
	for($f = 0; $f < $nrChains; $f++){
		if(`grep \" DA \" $path/mdrun_$root/$root\_solv_min_$f.pdb` ne ""){
			print " CHAIN $f: DNA\n";
			`genrestr -f $path/mdrun_$root/$root\_solv_min_$f.pdb -o $path/mdrun_$root/posre_DNA_chain_$chain[$f].itp 2>>$log_err 1>>$log_out <<EOF\n1\nEOF `;
			open(POSRE,"$path/mdrun_$root/posre_DNA_chain_$chain[$f].itp");
			open(TMPOUT,">$path/mdrun_$root/posre_DNA_chain_$chain[$f].itp.tmp");
			while(<POSRE>){
				$_ =~ s/1000/ 100/g;
				print TMPOUT $_;
			}
			close POSRE;
			close TMPOUT;
			`rm -rf $path/mdrun_$root/posre_DNA_chain_$chain[$f].itp`;
			#`mv $path/mdrun_$root/posre_DNA_chain_$chain[$f].itp.tmp $path/mdrun_$root/posre_DNA_chain_$chain[$f].itp`;
		}
		else{
			print " CHAIN $f: Protein\n";
			`genrestr -f $path/mdrun_$root/$root\_solv_min_$f.pdb -o $path/mdrun_$root/posre_Protein_chain_$chain[$f].itp 2>>$log_err 1>>$log_out <<EOF\n4\nEOF `;
		}
		if($nrChains == 1){
			`mv $path/mdrun_$root/posre_Protein_chain_$chain[$f].itp $path/mdrun_$root/posre.itp`;
		}	
	}


	#for($f = 0; $f < $nrChains; $f++){
	#	`genrestr -f $path/mdrun_$root/$root\_solv_min_$f.pdb -o $path/mdrun_$root/posre_Protein_chain_$chain[$f].itp <<EOF\n4\nEOF `;
	#	if($nrChains == 1){
	#		`mv $path/mdrun_$root/posre_Protein_chain_$chain[$f].itp $path/mdrun_$root/posre.itp`;
	#	}
	#}
	# - Unfreeze protein and only restraint backbone.
	#`genrestr -f $path/mdrun_$root/$root\_solv_min.pdb -o $path/mdrun_$root/posre.itp <<EOF\n4\nEOF`;



# Generate TPR file:
	`grompp $VERBOSE -f $path/mdrun_$root/minim_solv.mdp -c $path/mdrun_$root/$root\_solv_min.pdb -p $path/mdrun_$root/$root\_solv.top -o $path/mdrun_$root/$root\_solv_min2.tpr 2>>$log_err 1>>$log_out `;

# RUN Minimization:
	print STDERR " Minimizing - step  ";
	$| = 1;
	$lengthStep = 1;
	open(RUN,"$call $VERBOSE -deffnm $path/mdrun_$root/$root\_solv_min2 -c $path/mdrun_$root/$root\_solv_min2.pdb 2>& 1 | ");
	while(<RUN>){
		if($swver == 1){print $_;}
		if(/^Step=\s+([0-9]+), Dmax/){
			for($k = 0; $k < $lengthStep; $k++){
				print "\b";
			}
			print "$1";
			$lengthStep = length($1);
		}
	}
	close RUN;
	print STDERR "\n";
}
if(! -e "$path/mdrun_$root/$root\_solv_min2.pdb"){
	
	print STDERR " Problems minimising system!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
else{
	
	print STDERR " System minimized!\n";
	print STDERR "------------------------------------------------------------------------------\n";
}
###############################################################################
#exit;
###############
##   STEP8.5   ##
###############################################################################

# 8.5- Run minimization with fixed Backbone -cg.

###############################################################################

print STDERR " Run min III: solvent & fixed backbone(CG)\n";


if(! -e "$path/mdrun_$root/$root\_solv_min3.pdb"){

# Create MDP file:
	open(OUT,"> $path/mdrun_$root/minim_solv.mdp");
	print OUT "define          	= -DPOSRES\n";
	print OUT "integrator		= cg\n";
	print OUT "emtol		= $emtol\n";
	print OUT "nsteps		= $minsteps\n";
	print OUT "nstenergy		= 1\n";
	print OUT "energygrps		= System\n";
	print OUT "coulombtype		= PME\n";
	print OUT "rcoulomb		= 0.9\n";
	print OUT "rvdw			= 0.9\n";
	print OUT "rlist		= 0.9\n";
	print OUT "fourierspacing 	= 0.12\n";
	print OUT "pme_order 		= $pme\n";
	print OUT "ewald_rtol 		= 1e-5\n";
	print OUT "pbc			= xyz\n";
	close OUT;

# Generate TPR file:
	`grompp $VERBOSE -f $path/mdrun_$root/minim_solv.mdp -c $path/mdrun_$root/$root\_solv_min2.pdb -p $path/mdrun_$root/$root\_solv.top -o $path/mdrun_$root/$root\_solv_min3.tpr 2>>$log_err 1>>$log_out `;

# RUN Minimization:
	print STDERR " Minimizing - step  ";
	$| = 1;
	$lengthStep = 1;
	open(RUN,"$call $VERBOSE -deffnm $path/mdrun_$root/$root\_solv_min3 -c $path/mdrun_$root/$root\_solv_min3.pdb 2>& 1 |");
	while(<RUN>){
		if($swver == 1){print $_;}
		if(/Step ([0-9]+), Epot/){
			for($k = 0; $k < $lengthStep; $k++){
				print "\b";
			}
			print "$1";
			$lengthStep = length($1);
		}
	}
	close RUN;
	print STDERR "\n";
}
if(! -e "$path/mdrun_$root/$root\_solv_min2.pdb"){
	
	print STDERR " Problems minimising system!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
else{
	
	print STDERR " System minimized!\n";
	print STDERR "------------------------------------------------------------------------------\n";
}

#exit;


###############
##   STEP9   ##
###############################################################################

# 9- Runs short production NVT.

###############################################################################
# NVT:
print STDERR " Run NVT\n";
	
	# - Short production NVT.

# Create MDP file:
if(! -e "$path/mdrun_$root/nvt.mdp"){
	open(OUT,"> $path/mdrun_$root/nvt.mdp");
	print OUT "define		= -DPOSRES\n";
	print OUT "integrator		= md\n";
	print OUT "dt			= $stepsize\n"; 
	print OUT "nsteps		= $rlNVPT\n"; # Default is 50ps
	print OUT "nstxout		= 0\n";
	print OUT "nstvout		= 0\n";
	print OUT "nstfout		= 0\n";
	print OUT "nstlog		= 1000\n";
	print OUT "nstxtcout		= 0\n";
	print OUT "nstenergy		= 5\n";
	print OUT "energygrps		= Protein Non-Protein\n";
	print OUT "nstcalcenergy	= 5\n";
	print OUT "nstlist		= 10\n";
	print OUT "ns-type		= Grid\n";
	print OUT "pbc			= xyz\n";
	print OUT "rlist		= 0.9\n";
	print OUT "coulombtype         	= PME\n";
	print OUT "rcoulomb	       	= 0.9\n";
	print OUT "rvdw 	       	= 0.9\n";
	print OUT "fourierspacing      	= 0.12\n";
	print OUT "pme_order	       	= $pme\n";
	print OUT "ewald_rtol		= 1e-5\n";	
	print OUT "gen_vel		= yes   \n";
	print OUT "gen_temp		= 200.0 \n";
	print OUT "gen_seed		= 9999  \n";
	print OUT "constraints		= all-bonds\n";
	print OUT "tcoupl		= V-rescale\n";            
	print OUT "tc-grps		= Protein  Non-Protein\n"; 
	print OUT "tau_t		= 0.1      0.1 \n";        
	print OUT "ref_t		= 298      298 \n";
	print OUT "pcoupl		= no\n";
	close OUT;
}

# Generate TPR file:
if(! -e "$path/mdrun_$root/$root\_nvt.tpr"){
	`grompp $VERBOSE -f $path/mdrun_$root/nvt.mdp -c $path/mdrun_$root/$root\_solv_min3.pdb -p $path/mdrun_$root/$root\_solv.top -o $path/mdrun_$root/$root\_nvt.tpr 2>>$log_err 1>>$log_out `;
	#print "grompp $VERBOSE -f $path/mdrun_$root/nvt.mdp -c $path/mdrun_$root/$root\_solv_min3.pdb -p $path/mdrun_$root/$root\_solv.top -o $path/mdrun_$root/$root\_nvt.tpr 2>>$log_err 1>>$log_out\n";

}
#exit;
# RUN NVT MD:
if(! -e "$path/mdrun_$root/$root\_nvt.gro"){
	print STDERR " Running:  ";
	$| = 1;
	$lengthStep = 1;
	open(RUN,"$call $VERBOSE -deffnm $path/mdrun_$root/$root\_nvt 2>& 1 |");
	while(<RUN>){
		if($swver == 1){print $_;}
		chomp($_);
		#print "$_\n";
		if(/step /){
			for($k = 0; $k < $lengthStep; $k++){
				print "\b";
			}
			print "$_";
			$lengthStep = length($_);
		}
	}
	close RUN;
	print STDERR "\n";
}

if(! -e "$path/mdrun_$root/$root\_nvt.gro"){
	
	print STDERR " Problems NVT!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
else{
	
	print STDERR " NVT finished!\n";
	print STDERR "------------------------------------------------------------------------------\n";
}
###############################################################################
#exit;

###############
##   STEP10   ##
###############################################################################

# 10- Runs short production NPT.

###############################################################################
# NPT:
	
	# - Short production NPT.

print STDERR " Run NPT\n";
# Create MDP file:
if(! -e "$path/mdrun_$root/npt.mdp"){
	open(OUT,"> $path/mdrun_$root/npt.mdp");
	print OUT "define		= -DPOSRES\n";
	print OUT "integrator		= md\n";
	print OUT "dt			= $stepsize\n"; 
	print OUT "nsteps		= $rlNVPT\n"; # Default is 50ps
	print OUT "nstxout		= 0\n";
	print OUT "nstvout		= 0\n";
	print OUT "nstfout		= 0\n";
	print OUT "nstlog		= 1000\n";
	print OUT "nstxtcout		= 0\n";
	print OUT "nstenergy		= 5\n";
	print OUT "xtc_precision	= 1000\n";
	print OUT "xtc-grps		= System\n";
	print OUT "energygrps		= Protein Non-Protein\n";
	print OUT "nstcalcenergy	= 5\n";
	print OUT "nstlist		= 5\n";
	print OUT "ns-type		= Grid\n";
	print OUT "pbc			= xyz\n";
	print OUT "rlist		= 0.9\n";
	print OUT "coulombtype         	= PME\n";
	print OUT "rcoulomb	       	= 0.9\n";
	print OUT "rvdw 	       	= 0.9\n";
	print OUT "fourierspacing      	= 0.12\n";
	print OUT "pme_order	       	= $pme\n";
	print OUT "ewald_rtol		= 1e-5\n";
	print OUT "tcoupl		= V-rescale\n";            
	print OUT "tc-grps		= Protein  Non-Protein\n"; 
	print OUT "tau_t		= 0.1      0.1 \n";        
	print OUT "ref_t		= 298      298 \n";
	print OUT "pcoupl		= Berendsen\n";
	print OUT "Pcoupltype		= Isotropic\n";
	print OUT "tau_p		= 1.0\n";
	print OUT "compressibility	= 4.5e-5\n";
	print OUT "ref_p		= 1.0\n";
	print OUT "gen_vel		= no\n";
	print OUT "constraints		= all-bonds\n";
	print OUT "refcoord_scaling     = all\n";
	close OUT;
}

# Generate TPR file:
if(! -e "$path/mdrun_$root/$root\_npt.tpr"){
	`grompp $VERBOSE -f $path/mdrun_$root/npt.mdp -c $path/mdrun_$root/$root\_nvt.gro -p $path/mdrun_$root/$root\_solv.top -o $path/mdrun_$root/$root\_npt.tpr 2>>$log_err 1>>$log_out `;
}
#exit;
# RUN NPT MD:
if(! -e "$path/mdrun_$root/$root\_npt.gro"){
	print STDERR " Running:  ";
	$| = 1;
	$lengthStep = 1;
	open(RUN,"$call $VERBOSE -deffnm $path/mdrun_$root/$root\_npt 2>& 1 |");
	while(<RUN>){
		if($swver == 1){print $_;}
		chomp($_);
		#print "$_\n";
		if(/step /){
			for($k = 0; $k < $lengthStep; $k++){
				print "\b";
			}
			print "$_";
			$lengthStep = length($_);
		}
	}
	close RUN;
	print STDERR "\n";
}

if(! -e "$path/mdrun_$root/$root\_npt.gro"){
	
	print STDERR " Problems NPT!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
else{
	
	print STDERR " NPT finished!\n";
	print STDERR "------------------------------------------------------------------------------\n";
}
###############################################################################
#exit;

###############
##   STEP11  ##
###############################################################################

# 11- Runs Production MD.

###############################################################################
# MD Simulation:

	# - Finally MD simulation.
print STDERR " Production run\n";

# Create MDP file:
if(! -e "$path/mdrun_$root/md.mdp"){
	open(OUT,"> $path/mdrun_$root/md.mdp");
	print OUT "integrator		= md\n";
	print OUT "tinit		= 0\n";
	print OUT "dt			= $stepsize\n"; 

# Edit the following line to set up the lenght of the production MD. Default is 10ns.

	print OUT "nsteps		= $rlMD\n"; # Default is 10ns
	print OUT "nstxout		= 50000\n";
	print OUT "nstvout		= 50000\n";
	print OUT "nstfout		= 0\n";
	print OUT "nstlog		= 1000\n";
	print OUT "nstxtcout		= 1000\n";
	print OUT "nstenergy		= 1000\n";
	print OUT "energygrps		= Protein Non-Protein\n";	
	print OUT "nstcalcenergy	= 5\n";
	print OUT "nstlist		= 5\n";
	print OUT "ns-type		= Grid\n";
	print OUT "pbc			= xyz\n";
	print OUT "rlist		= 0.9\n";
	print OUT "coulombtype         	= PME\n";
	print OUT "rcoulomb	       	= 0.9\n";
	print OUT "rvdw 	       	= 0.9\n";
	print OUT "fourierspacing      	= 0.12\n";
	print OUT "pme_order	       	= $pme\n";
	print OUT "ewald_rtol		= 1e-5\n";
	print OUT "tcoupl		= V-rescale\n";            
	print OUT "tc-grps		= Protein  Non-Protein\n"; 
	print OUT "tau_t		= 0.1      0.1 \n";        
	print OUT "ref_t		= 298      298 \n";
	print OUT "pcoupl		= Berendsen\n";
	print OUT "Pcoupltype		= Isotropic\n";
	print OUT "tau_p		= 2.0\n";
	print OUT "compressibility	= 4.5e-5\n";
	print OUT "ref_p		= 1.0\n";
	print OUT "gen_vel		= no\n";
	print OUT "constraints		= all-bonds\n";
	print OUT "constraint-algorithm = Lincs\n";
	print OUT "unconstrained-start	= yes\n";
	print OUT "lincs-order		= 4\n";
	print OUT "lincs-iter		= 1\n";
	print OUT "lincs-warnangle	= 30\n";
	#print OUT "comm_mode		= linear\n";
	close OUT;
}

# Generate TPR file:
if(! -e "$path/mdrun_$root/$root\_md.tpr"){
	`grompp $VERBOSE -f $path/mdrun_$root/md.mdp -c $path/mdrun_$root/$root\_npt.gro -p $path/mdrun_$root/$root\_solv.top -o $path/mdrun_$root/$root\_md.tpr 2>>$log_err 1>>$log_out `;
}

# RUN Production MD:
if(! -e "$path/mdrun_$root/$root\_md.gro"){
	print STDERR " Running:  ";
	$| = 1;
	$lengthStep = 1;
	open(RUN,"$call $VERBOSE -deffnm $path/mdrun_$root/$root\_md 2>& 1 |");
	while(<RUN>){
		if($swver == 1){print $_;}
		chomp($_);
		#print "GO |$_|\n";
		if(/step /){
			for($k = 0; $k < $lengthStep; $k++){
				print "\b";
			}
			print "$_";
			$lengthStep = length($_);
		}
	}
	close RUN;
	print STDERR "\n";
}

if(! -e "$path/mdrun_$root/$root\_md.xtc"){
	
	print STDERR " Problems production run!!!\n";
	print STDERR "------------------------------------------------------------------------------\n";
	exit;
}
else{
	
	print STDERR " Production run finished!\n";
	print STDERR "------------------------------------------------------------------------------\n";
}
###############################################################################


##############
##   END    ##
###############################################################################

$| = 0;
sub printHelp{
        print STDERR "USAGE:    AGroS <PDB FILE | PDB CODE> [<CHAIN: ...>] [OPTIONS]\n";
	print STDERR "OPTIONS:  [-dir PATH] 		directory to save results to\n";
	print STDERR "          [-threads int]  	number of processors to use (1)\n";
	print STDERR "          [-noscwrl]      	don't use scwrl\n";
	print STDERR "          [-v]                    verbose and a lot of text\n\n";
	
	print STDERR "          [-minSteps int]     	steps for minimisation (5000)\n";
	print STDERR "          [-lengthNVPT int]    	time for NVT & NPT in ps (50)\n";
	print STDERR "          [-lengthMD int]     	time for MD in ps (10.000)\n";
	print STDERR "          [-cutoffSTRW int]	cutoff in A for structural water to keep (15)\n\n";
	
	print STDERR "          [--gromacsPATH PATH] 	path to gromacs distribution\n";
	print STDERR "          [--scwrlPATH PATH]   	path to scwrl distribution\n";
	print STDERR "          [--scriptPATH PATH]   path to helper scripts needed\n\n";

	
	print STDERR "          [--jp]                just prepare structure for GROMACS\n";
        exit(1);
}
